<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="UTOPIA">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="UTOPIA">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UTOPIA">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>UTOPIA</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">UTOPIA</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/西方哲学十五讲(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="UTOPIA">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/西方哲学十五讲(1)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T14:27:45+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="《西方哲学十五讲》课程记录（1）"><a href="#《西方哲学十五讲》课程记录（1）" class="headerlink" title="《西方哲学十五讲》课程记录（1）"></a>《西方哲学十五讲》课程记录（1）</h3><h5 id="一-智慧的痛苦"><a href="#一-智慧的痛苦" class="headerlink" title="一.  智慧的痛苦"></a>一.  智慧的痛苦</h5><ul>
<li>哲学问题没有一个定论，不能揭示普遍性、确定性的知识</li>
<li>不能以衡量科学的标准来衡量哲学，哲学与自然科学有界限</li>
<li>然而，古典哲学的哲学家们试图让它成为科学；但是这个理想最终破灭</li>
<li>世界上的道理和道理都是相互冲突的，每个哲学家都会把解决问题的方式推到极致，同时每个哲学家的方式都不同。</li>
<li>通常，哲学的大道理大到没有办法去验证的程度，因此道理和道理的冲突变成没有道理。哲学的对象是理想性的，乌托邦式的，即使使用非常严谨的一套逻辑，但是没有足够的经验事实去验证对象。因此，哲学剩下来的就是一套无懈可击的逻辑。在这个逻辑背后，我们需要关注整套理论的大前提。</li>
<li>哲学是无用之用；用来解决精神问题</li>
<li>古代哲学家将哲学认为是爱智，而不是智慧本身；智慧所标志的是无限永恒的理想境界，而人类的追求就是要热爱这个理想境界</li>
<li>要学习的不是具体的知识内容，而是学习哲学家面对的问题及其他们<strong>解决问题的方式</strong></li>
<li>科学要诉诸理性，把握事物的本质，解决自然的问题；宗教关注<strong>超自然</strong>世界，面对终极关怀的问题，依赖的是信仰诉诸情感；而哲学位于两者之间，讲理性，但也面临着终极关怀的问题</li>
<li>哲学究竟面临着什么类型的问题？是一类没有答案的问题（没有标准答案，只有不同的解决方法）</li>
<li>每个哲学家都会把解决问题的方式推到极致，并且在路的尽头竖起牌子：此路不通。那么为什么还要去追问这些解决不了的问题？</li>
<li>亚当夏娃偷食禁果后，意识到了自己的有限性，即有了智慧后产生了对生死的恐惧，对有限的恐惧。</li>
<li>对于生与死的矛盾的问题，当我们无法逃避、不得不面对时，利用哲学的方式将它变成有限无限</li>
<li>人生有限，但每个人都会去思考无限的问题，即使眼前的问题没有搞清楚。这是人的局限性。这也是人意识到了自己渺小的同时试图去创造永恒、无线境界的开始。</li>
<li>哲学是哲学史，哲学史是问题史</li>
<li>读哲学像猜谜，只能通过其表述去体会<strong>他要描述的问题</strong>；然而哲学无法使用我们的一套日常语言进行表述。</li>
<li>学习方法：<ul>
<li>找出问题</li>
<li>熟悉其术语、概念</li>
<li>了解逻辑</li>
<li>理解著作</li>
</ul>
</li>
<li>希腊哲学的特点：偏爱普遍性；追求合理性——试图要给事物的存在找出合理原因；学以致“知”；使用科学思维方式（即抽象思维，将事物的属性和本质抽离开进行考虑来进行普遍概括）</li>
</ul>
<p>### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/booooks01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="UTOPIA">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/booooks01/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T14:17:36+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="回答不了的2018（1）"><a href="#回答不了的2018（1）" class="headerlink" title="回答不了的2018（1）"></a>回答不了的2018（1）</h4><ul>
<li><p>长篇小说</p>
<ul>
<li>幻影书</li>
</ul>
<p>保罗·奥斯特描述的又一个梦境。</p>
<p>这也是一个故事套着故事的故事。齐莫的故事里套着海克特的故事，海克特的故事里套着电影的故事。每一个故事的主角的表象生活在我们看来都没有那么糟糕，但是他们都有一个共同点：擅长自我毁灭。正如卷首引用的夏多布里昂的话：</p>
<p>“人不只有一次生命。人会活很多次，周而复始，那便是人生之所以悲惨的原因”</p>
<p>当齐莫失去了家人，辞掉了工作，将自己的生活完全从现实剥离，他亲手把自己推向了一个空荡荡的深渊。当海克特的故事来到了齐莫的身边，我们满怀惊奇的以为它的生活即将被这样一个插曲推向正常，却发现这个故事也是一个更深、更无头绪的深渊。“人会活很多次”，每一次都有新的事物/故事/人物将人从原来的痛苦中拉出来，却因为人本质的自我毁灭倾向，被迫再一次预见痛苦的结局。</p>
<p>此外，有关这些故事的真实性界限也是小说探讨的一个话题。海克特的故事荒诞随意，一个昔日默片的著名表演艺术家隐姓埋名为了赎罪，最后重拾旧好拍起了不会被公开的电影。那么是否能说，自从他隐姓埋名的那一刻起，他就不再是海克特，他过起了别人的生活；而那些反应他荒诞内心和忏悔情绪的电影也因为最后的被毁而无法作为其活过的证明。所以，真实的海克特早已死去。一个有趣的细节是，齐莫在写完&lt;海克特的默片世界&gt; ，齐默离开了纽约，开始翻译夏多布里昂的《墓后回忆录》。这个情节似乎在暗示，真实的海克特的这一生已经过完，许多事情即将被遗忘在墓地之中。</p>
<p>这部小说的嵌套、重叠、循环的情节让人恍惚，似乎不是在读一本小说，而是反反复复，从一个深渊滑向另一个深渊。</p>
<ul>
<li>弗兰妮与祖伊</li>
</ul>
<p>读的塞林格的第一本书。</p>
<p>整本书所说的，是自我厌弃和放逐，是不愿流露的爱，令人困惑的信仰，与自己和解再与世界和解，放弃自我抑或成为自我。</p>
<p>但是究竟什么样才是符合生活的方式呢？弗兰妮选择自我厌弃，一遍一遍祷告企图抛弃自我达到人生的平静与无为。她选择抛弃的东西与其说是自我，不如说是她与普遍世界产生的矛盾、她不愿意接受并且蔑视的痛苦。当她选择了一条看上去真实、毫无人为痕迹的道路，她想要直通自我的本质，以从令人恶心恐惧的生活细节中完整的抽离出自己的灵魂。</p>
<p>但如果有这样一条路，它并不是通向智慧，因为它是一条完全概念化的道路。我们选择爱智，也不是为了自我实现，更不是为了自我厌弃。我们选择的是一个过程，一个不断产生困惑、不断发生矛盾进而不断和解的过程，这个过程最终是通向自我实现还是厌弃，我们无法知道，也不需要关注。</p>
<p>​</p>
<p>​</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="UTOPIA">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/1/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T10:35:38+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h3><ol>
<li>全排列</li>
</ol>
<ul>
<li>暴力循环（每一位便利集合）</li>
<li>交换的思想：对整个序列做全排列即为对子序列做全排列；（递归思想）</li>
<li>即每一次从集合中选出一个元素，对剩下的元素做全排列。</li>
</ul>
<p>void perm（k+1）：</p>
<p>for（i=k；i&lt;m;++i）{</p>
<p>​    swap(k,i) 按顺序从k～e中选择一个元素与k交换</p>
<p>​    perm（k+1） 递归，k+1</p>
<p>​    swap（k，i）换回前缀    （保证每次选择元素的并行）    </p>
<p>}</p>
<p>交换过程：1,1;2,2;3,3;3,3;2,2,;2,3;3,3;3,3;2,3;1,1;……….</p>
<p>——均为对称分布</p>
<p><img src="/Users/apple/Downloads/201204081744271555.png" alt="0120408174427155"></p>
<p>2.全组合</p>
<ul>
<li><p>每一次从集合中选择一个元素，然后对剩下的n-1个元素进行k-1次组合</p>
<p>void comb（n，k）：</p>
<p>if():</p>
<p>​    print</p>
<p>for（i=n；i&gt;=k;i–）{</p>
<p>​    subset[k-1]=s[i-1] 反向选择一个元素，放入集合中</p>
<p>​    comb(i-1，k-1)</p>
<p>}</p>
<p>（4，2） i从4减少到2；3到1；2到0</p>
<p>​</p>
<p>​</p>
</li>
</ul>
<ol start="3">
<li><p>Reverse string:</p>
<ul>
<li><ol>
<li>单纯的reverse：c语言中做一个swap就行</li>
<li>一个句子中每个单词reverse：往前执行，设置好子串的起始index和末尾index；注意识别空格位置作为末尾index+1</li>
<li>每k个一组，reverse每个组的前k／2个</li>
</ol>
</li>
</ul>
</li>
<li><p>找最长不重复子串：</p>
<p>问题：不知道子串的长度？</p>
<p>Idea1:</p>
<ol>
<li>First char of input string is first char of repeated substring</li>
<li>Last char of input string is last char of repeated substring</li>
<li>Let S1 = S + S (where S in input string)</li>
<li>Remove 1 and last char of S1. Let this be S2</li>
<li><strong>If S exists in S2 then return true else false</strong></li>
<li>Let i be index in S2 where S starts then repeated substring length i + 1 and repeated substring S[0: i+1]</li>
</ol>
<p>Idea2:</p>
<ol>
<li>The length of the repeating substring must be a divisor of the length of the input string</li>
<li>Search for all possible divisor of <code>str.length</code>, starting for <code>length/2</code></li>
<li><strong>If <code>i</code> is a divisor of <code>length</code>, repeat the substring from <code>0</code> to <code>i</code> the number of times <code>i</code> is contained in <code>s.length</code></strong></li>
<li>If the repeated substring is equals to the input <code>str</code> return <code>true</code></li>
</ol>
</li>
<li><p><strong>二叉树的合并问题</strong>（leetcode 617）</p>
<ul>
<li>递归的用处——返回值用于更换子树</li>
<li>返回值是什么？</li>
<li>何时递归？</li>
<li>在何处递归？</li>
</ul>
<blockquote>
<p>解决方案：</p>
<p>1.返回值为value修改后的节点（如果t1不存在，则直接返回t2（使用t2的节点），反之，如果t2不存在，则直接返回t1（使用t1的节点））</p>
<p>2.何处何时递归？   修改值；左子树递归；右子树递归</p>
</blockquote>
</li>
<li><p>二叉搜索树(leetcode 669)</p>
<p>在二叉查找树中：<br>(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>(03) 任意节点的左、右子树也分别为二叉查找树。<br>(04) <strong>没有键值相等的节点</strong>（no duplicate nodes）</p>
<p>解法：</p>
<ul>
<li>当root的值位于<code>L</code>和<code>R</code>之间，则递归修剪其左右子树，返回root。</li>
<li>当root的值小于<code>L</code>，则其左子树的值都小于<code>L</code>，抛弃左子树，返回<strong>修剪过</strong>的右子树。</li>
<li>当root的值大于<code>R</code>，则其右子树的值都大于<code>R</code>，抛弃右子树，返回<strong>修剪过</strong>的左子树。</li>
</ul>
<p>解释：每一步都是一次修剪，即返回的子树都是修剪过后的子树。对每一个节点获取其修建过后的子树，再将该子树赋值给当前节点的左／右子树</p>
<p>调试：</p>
<p>注意return的位置。当根节点的数值比范围大，<strong>直接返回</strong>左子树修剪过后的根节点；右边同理；而范围合适时，<strong>左右边都修剪后再返回当前根节点。</strong></p>
<p>修建的原理：当对左右边修剪时，已知范围不合适返回的是其子树，因此某一个根节点的孩子被赋予的是范围合适情况下的子树的根节点。因此修剪成功。</p>
<p>​</p>
<p><strong>Note：建立二叉搜索树的过程：</strong></p>
<ul>
<li><p>设置node类型指针root；root=NULL。root的地址传入insert函数作为参数：<em> </em> T 即T=&amp;root。root=NULL，所以* T=NULL。（但T的值是root地址）</p>
<pre><code>root      TreeNode *        0x1005046d0
</code></pre></li>
<li><p>新增节点 pinsert，让* T=pInsert; 此时root被分配了空间和新节点。（T-&gt;root-&gt;NULL）</p>
</li>
<li><p>迭代后，传入T=&amp;(root-&gt;lchild),此时*T的值为当前节点孩子节点的值。</p>
</li>
</ul>
</li>
<li><p>二叉树——计算每一层的均值(leetcode 637)</p>
<ul>
<li><p>思路：<strong>BFS算法——从上到下一层一层的计算，直到第i层结束。</strong>用队列方式实现，第i层的节点加入队列后，再加入第i+1层的节点；这样优先处理第i曾节点。</p>
</li>
<li><p>java实现队列：Queue借口：在java5中新增加了java.util.Queue接口，用以支持队列的常见操作。该接口扩展了java.util.Collection接口。</p>
<blockquote>
<p> 使用offer()来加入元素，使用poll()来获取并移出元素。它们的优点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。 如果要使用前端而不移出该元素，使用element()或者peek()方法。</p>
</blockquote>
<p>使用：Queue<string> queue = new LinkedList<string>();</string></string></p>
<p>过程：</p>
<pre><code>![creensho](/Users/apple/Library/Group Containers/Q79WDW8YH9.com.evernote.Evernote/Evernote/quick-note/13272016-personal-app.yinxiang.com/quick-note-Nkq0hI/attachment--HrgWEm/screenshot.png)
</code></pre><p>​    </p>
<p>说明：使用循环，将节点存储在队伍中，每次(for 0 ~n)入队一层元素；(for 0 ~n)出队一层元素;</p>
</li>
</ul>
</li>
<li><p>二叉树——找最大的深度</p>
<p>思路一：BFS深度优先查找</p>
<p>​</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count==<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       Queue&lt;TreeNode root&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(root== <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       queue.offer(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> size=queue.size();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(size-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">               TreeNode node=queue.poll();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   queue.offer(mnode.left);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   queue.offer(node.right);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           count++;<span class="comment">//计算层数</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> count;  </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>count是最深的层数；</p>
<p>​</p>
<p>​</p>
<p>思路二：return大的数；每返回一层num+1   </p>
<p><img src="/Users/apple/Library/Group Containers/Q79WDW8YH9.com.evernote.Evernote/Evernote/quick-note/13272016-personal-app.yinxiang.com/quick-note-Nkq0hI/attachment--SGB31k/screenshot.png" alt="creensho"></p>
<p>​</p>
<p>​</p>
</li>
<li><p>镜像对称二叉树（leetcode 226）</p>
<ul>
<li><p>思路一：BFS（循环）</p>
<blockquote>
<p>每次左右节点入队前修改下左右节点的位置</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>思路二：DFS（迭代）</p>
<blockquote>
<p>修改返回值：(注意要进行中间值的传递)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt;         TreeNode temp=root.left;</span><br><span class="line">&gt;         temp=invertTree(root.right);</span><br><span class="line">&gt;         root.right=invertTree(root.left);</span><br><span class="line">&gt;         root.left=temp;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<ol start="10">
<li><p><strong>二叉搜索树</strong>元素求和问题（leetcode653 Two Sum IV - Input is a BST）</p>
<p>tip：对二叉搜索树进行中序遍历即可得到递增序列</p>
<ul>
<li>思路：先使用<strong>中序遍历</strong> 生成二叉搜索树的递增list，设置i，j两个指针从两头到中间找和为sum的情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root ==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">       inorder(root.left,nums);</span><br><span class="line">       nums.add(root.val);</span><br><span class="line">       inorder(root.right,nums);</span><br><span class="line">   &#125;<span class="comment">//中序遍历</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>二叉搜索树 （leetcode  538:Convert BST to Greater Tree）</p>
<ul>
<li><p>将每个节点的val加上比他大的值</p>
</li>
<li><p>思路：从右往左遍历，维护一个sum，每次返回时sum=root.val（）。sum如何维护？使用到java的实例变量：</p>
<blockquote>
<h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><ol>
<li><strong>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</strong></li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null<strong>。变量的值可以在声明时指定，也可以在构造方法中指定；</strong></li>
<li><strong>实例变量可以直接通过变量名访问</strong>。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>判断两个二叉树是否相同？</p>
<ul>
<li><p>思路：遍历得到数组，比较两个数组？麻烦</p>
</li>
<li><p>每次Recursion时比较val是否相同；注意递归的状态——</p>
<blockquote>
<p>val相同，递归下一子树；val不同，return false；</p>
<p>终态——子节点==null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&gt;         <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&gt;         <span class="keyword">if</span>(p.val==q.val)&#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>二叉树左叶子的和</p>
<ul>
<li><p>思路：判断是否为左叶子？孩子节点为null；设置标志标示其为左孩子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftLeaves</span><span class="params">(struct TreeNode* root,<span class="keyword">int</span> *sum,<span class="keyword">int</span> sign)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    LeftLeaves(root-&gt;left,sum,<span class="number">1</span>);<span class="comment">//注意传入的不是sum的地址！！因为这里的sum不是int整数，而是一个指针。直接传入sum指针即可。</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>&amp;&amp; sign) &#123;</span><br><span class="line">        <span class="comment">//printf("%d",root-&gt;val);</span></span><br><span class="line">        (*sum)+=root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LeftLeaves(root-&gt;right,sum,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>每次递归左孩子时设置标志，标记当前节点为左孩子；</li>
<li>当前需要修改一个类似全局变量的值时，可以使用指针，副函数中修改指针所指向的变量的值；主函数中将实际区域的地址给该指针，即<strong>可在副函数中修改主函数的变量值</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>找到二叉树中两个节点的最长路径（起点终点任意）</strong>（nice solution！！）</p>
<ul>
<li>思路：设置result存储每一层的最长路径；返回值是左右孩子中的<strong>最大深度</strong>；比较当前层的<strong>最长路径</strong>（左深度+右深度）与 result的值，更新result。</li>
<li>java实现？？</li>
</ul>
</li>
<li><p>将二叉树节点的值按层依次输出？</p>
<ul>
<li>思路：BFS／DFS</li>
<li>BFS algo: queue +list.add(node.val)+<strong>result.add(0,list)(将list的顺序倒排！！！）</strong></li>
</ul>
</li>
<li><p>Given a binary tree, return all root-to-leaf paths.<strong>（nice solution！）</strong>（leetcode 257）</p>
<ul>
<li><p>DFS？</p>
</li>
<li><p>java连接字符串？+</p>
</li>
<li><p>java删除最后一个元素？list.remove</p>
</li>
<li><p>思路：<strong>自底向上（叶子到根）构成每条path</strong>；叶子结点与非叶子结点的path连接方式分开；每次<strong>返回当前path</strong>并与parent结点连接；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> paths;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;<span class="comment">//叶子结点，无-&gt;</span></span><br><span class="line">            paths.add(root.val+<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (String path : binaryTreePaths(root.left)) &#123;</span><br><span class="line">             paths.add(root.val + <span class="string">"-&gt;"</span> + path);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (String path : binaryTreePaths(root.right)) &#123;</span><br><span class="line">             paths.add(root.val + <span class="string">"-&gt;"</span> + path);<span class="comment">//双亲节点与孩子结点连接</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> paths;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ol>
<p>Linkedlist与arraylist的区别？ </p>
<ol start="17">
<li><p>leetcode 784（nice  solution using BFS！ ）</p>
<p>Examples:Input: S = “a1b2”Output: [“a1b2”, “a1B2”, “A1b2”, “A1B2”]</p>
<ul>
<li><p>大小写的范围？A-Z：65～90 a-z：97～122</p>
</li>
<li><p>什么时候invert？组合问题？迭代？</p>
</li>
<li><p>BFS／DFS问题。</p>
</li>
<li><p>思路：1. BFS：出队当前字符串，入队修改大小写后的两个字符串。</p>
<blockquote>
<p>java string类：</p>
<ul>
<li>valueof方法：返回<strong>字符串表示</strong>形式</li>
<li>charAt() 方法: 返回<strong>指定索引处</strong>的字符。索引范围为从 0 到 length() - 1。</li>
<li>toCharArray：返回一个<strong>字符数组</strong>，该字符数组中存放了当前字符串中的所有字符</li>
</ul>
<p>java character类：对单个字符进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Character ch = <span class="keyword">new</span> Character(<span class="string">'a'</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>isletter()</li>
<li>isDigit()</li>
<li>toUpperCase()大写形式</li>
<li>toLowerCase()小写形式</li>
<li>toString()字符串形式</li>
<li>new LinkedList&lt;&gt;(queue) 将queue类型转换为List类型</li>
</ul>
<p><strong>string和character的转换：</strong></p>
<ol>
<li><p><strong>字符串转字母数组：toCharArray</strong></p>
</li>
<li><p><strong>字母修改</strong></p>
</li>
<li><strong>字母数组再转回字符串：valueof</strong></li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>leetcode 746: Min Cost Climbing Stairs 上楼梯问题（path）（<strong>经典DP问题</strong>）<strong>(important solution!!)</strong></p>
<ul>
<li>约束：可走1步／2步；可以从第0阶开始；可以从第1阶开始</li>
<li>思路：每一步的代价是上一步的代价+1或者是上上一步的代价+2；取上／上上一步代价较小的那个走。<ul>
<li>问题：上楼梯全局最优？对于每个位置i，最小代价=走到i-1点的min(cost)+cost（i）or 走到i-2点的min(cost)+cost(i)，取较小值即可。利用<strong>DP往前推</strong>即可。</li>
<li>找好起始点（i=2）</li>
</ul>
</li>
</ul>
</li>
<li><p>leetcode 70：climbing stairs</p>
<ul>
<li><p>question：You are climbing a stair case. It <strong>takes <em>n</em> steps</strong> to reach to the top.</p>
<p>Each time you can either <strong>climb 1 or 2 steps</strong>. In <strong>how many distinct ways can you climb to the top?</strong></p>
</li>
<li><p>约束：可走1步／2步；从第0阶开始；n个台阶</p>
</li>
<li><p>思路：<strong>到达n阶的路径数量为n-1阶路径数量+n-2阶路径数量。</strong>由于终点不重叠，这两个集合中的路径也不重叠。</p>
</li>
<li><p><strong>斐波那契问题</strong></p>
</li>
</ul>
</li>
<li><p>leetcode 59 Maximum Subarray（nice solution！！）</p>
<ul>
<li><p>找相毗邻的和最大的子数组：</p>
</li>
<li><p>思路：<strong>假设我们已经解决了前i-1个数字的最大和，</strong>那么对于前i个元素来说，最大和要么是<strong>前i-1个元素的最大和</strong>，要么是<strong>以i为结尾的子数组</strong>的最大和（以i为结尾的数组的和一定为以i-1为结尾的子数组的最大和+A[i] or A[i]）。从下到上依次进行。</p>
<p>maxeendinghere=maxmaxendinghere+A[ℹ]，A[i]</p>
<p>maxsofar=max（maxsofar，maxendinghere）</p>
</li>
</ul>
</li>
<li><p>leetcode 198 （nice solution！！）</p>
<ul>
<li><p>至少隔一座房子抢劫，max profit？</p>
</li>
<li><p>思路：DP问题？i座房子的最大收益=<strong>抢劫到第i-1座房子收益 or 抢劫到第i座房子收益</strong></p>
</li>
<li><p>难点：不确定性——从奇数or偶数开始抢劫？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">      <span class="comment">//前i个数中最大的抢劫收益</span></span><br><span class="line">      <span class="comment">//奇偶分别讨论</span></span><br><span class="line">      <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">          a=max(a+nums[i],b);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          b=max(a,b+nums[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max(a,b);</span><br></pre></td></tr></table></figure>
<p>或设置两个max，分别存储从奇数开始抢劫or从偶数开始抢劫。</p>
</li>
</ul>
</li>
<li><p>leetcode 338  Counting Bits</p>
<ul>
<li>思路：arr[i]=i&amp;1?arr[i/2]+1:arr[i/2]</li>
<li>即每一个整数的位数是该整数／2左移一位得到的；当最低位是1时，整数右移会损失一位，因此要+1</li>
<li>dp问题，即从小到大求解。</li>
</ul>
<p>数组直接复制的方法？</p>
</li>
<li><p>leetcode 647 找回文子串 的个数 （nice problem！！）</p>
<ul>
<li>思路：判断每个子串是否是回文，遍历（复杂度高）。使用DP solution——</li>
<li>extendPalindrome<strong>(s, i, i)</strong>; // 奇数odd length;            extendPalindrome<strong>(s, i, i + 1)</strong>; // 偶数even length</li>
</ul>
<p>对于每一个数，以它为中心的奇数子串+以她开头的偶数子串设定为他需要判断的子串。</p>
<ul>
<li><p><strong>怎样判断回文？？</strong></p>
</li>
<li><p>函数分为几个部分：</p>
<ol>
<li>回文字符串的判断</li>
<li>字符串的截取</li>
<li>偶数和奇数字符串的分别判断</li>
</ol>
<ul>
<li><p>其中回文的判断与字符串的额截取可以合并。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkPalindrome(<span class="keyword">char</span>* s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">    <span class="keyword">while</span>(s[i]==s[j]) i++;j--;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>关键1：count的计数——放在回文的判断中。如果while true，说明当前i，j包含子串是回文串。</p>
</li>
<li><p>关键2: i，j的选择——i=j延伸——奇数子串；j=i+1延伸——偶数子串</p>
</li>
<li><p><strong>dp的思想体现——只有i，j包含的子串为回文，i-1和j+1包含的子串才可能是回文</strong></p>
</li>
</ul>
</li>
<li><p>leetcode712:Minimum ASCII Delete Sum for Two Strings. （经典DP问题！！！！！没懂！！！！！！！！！！！！！！！！）</p>
<ul>
<li><p>思路：删除哪些字母使得：1. Equal；2. 字母sum最小？</p>
</li>
<li><p>最长公共子序列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str1.charAt(i<span class="number">-1</span>)==str2.charAt(j<span class="number">-1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;&#125; <span class="keyword">else</span>&#123;  </span><br><span class="line">                    dp[i][j]=Math.max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);  </span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>常规LCS中dp中存储的是LCS路径的长度， 对于 dp[i][j]=Math.max(dp[i-1][j], dp[i][j-1]);  每次比较两个dp中长度大小来选择下一条路径和当前最长路径长度</p>
</li>
<li><p><strong>本题中由于加入ASCII，dp中存储的不是该条路径的最长长度，而是该条路径上的最小cost，根据cost大小来选择下一条路径</strong>。</p>
</li>
<li><p>注意：两边的初始化也不是0。当选择下一条路径时，如果字符不相同，那么选择字符ASCII小的路径走。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1len;i++)&#123;</span><br><span class="line">        <span class="built_in">array</span>[i+<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">array</span>[i][<span class="number">0</span>]+s1[i]; <span class="comment">//初始化， a[i][0]为s1前i个字母的🐎和</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>初始化的意义：</p>
</li>
<li><p>因此代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s2len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">                <span class="built_in">array</span>[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="built_in">array</span>[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">else</span>&#123;</span><br><span class="line">                a=<span class="built_in">array</span>[i][j+<span class="number">1</span>]+s1[i];</span><br><span class="line">                b=<span class="built_in">array</span>[i+<span class="number">1</span>][j]+s2[j];</span><br><span class="line">                <span class="built_in">array</span>[i+<span class="number">1</span>][j+<span class="number">1</span>]=a&lt;b?a:b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>leetcode 246 Maximum Length of Pair Chain(未完)</p>
<ul>
<li>最长递增子序列问题——递增的次数最多／递增的增量最大</li>
<li>本题是求递增次数最多的一条链</li>
<li>思路：典型的贪心算法问题。每次都找<strong>第一个结束时间最早</strong>的数组。</li>
</ul>
</li>
</ol>
<ol start="26">
<li><p>leetcode 343 integer break</p>
<ul>
<li>break it into the sum of <strong>at least</strong> <strong>two positive integers</strong> and maximize the product of those integers. Return the <strong>maximum product</strong></li>
<li>思路：分裂一个数字使得乘积最大——DP问题 背包问题</li>
<li>首先建立一个dp数组用于存储已经解决的子问题。背包问题中，局部最优可得到全局最优，即第n-i个数的maximum product * i 可达到n的最优maximum product</li>
<li>简便方法：当n&gt;4时，每个数的最大乘积中必然有2／3（5，6，7，8，9，10·····）即最大乘积必然为2和3的多个数相乘（证明？）</li>
</ul>
</li>
<li><p>leetcode 714 best time to <strong>buy and. sell stock with fee</strong></p>
<ul>
<li><p>给定一组某一stock在每一天的价格，买卖次数不限，每次买入必须在卖出之后，且每次卖出时都需要fee的手续费，求解最大的收益。</p>
</li>
<li><p>思路：</p>
<ul>
<li><p>DP</p>
</li>
<li><p>贪心算法</p>
<ol>
<li>dp solution：对于第i天的收益有两种情况：</li>
</ol>
<ul>
<li><p>手中无stock：保持前一天 or 今天卖出</p>
</li>
<li><p>手中有stock ：保持前一天 or 今日买入</p>
<p>注意：第i天的情况只与第i-1天有关。</p>
<p>每天都有一个hold和cash的值，记录第i-1天手中有／无石头的收益。第i天根据这个收益来判断当前是否需要持有石头。（即，贪心思想，第i-1天收益最大，第i天就收益最大。）</p>
<ol start="2">
<li>贪心算法：注意有fee，需要权衡买卖次数和交易profit。比如序列1 3 2 8，如果发现2小于3就完成交易买1卖3，此时由于fee=2，（3-1-fee）+(8-2-fee)&lt;(8-1-fee)，所以说明卖早了。<ul>
<li>设置max表示当前最大price。min表示当前最小price。移动max，只要max-min</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>leetcode 78 subsets（basic problem）</p>
<ul>
<li><p>problem：Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p>eg：Input: nums = [1,2,3] Output:[  [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  []]</p>
</li>
<li><p>思路：全排列问题。每次拿出一个元素，对剩下的元素全排列；交换；（实现？？？？？）</p>
</li>
<li><p>思路二：首先根据数学方法得到每个数组的大小，再根据bitmap得到每个数组中应该放进去的数有哪些；（）利用不断移位的方法将数移到最低位再放进去。nice but complex solution。</p>
</li>
<li><p>给的解法（0ms）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">subsets</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>** columnSizes, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i, j, count = <span class="number">1</span>, size;</span><br><span class="line">    <span class="keyword">int</span>** result = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * (<span class="number">1</span>&lt;&lt;numsSize)); <span class="comment">//返回几个solution</span></span><br><span class="line">    <span class="keyword">int</span> *col = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (<span class="number">1</span>&lt;&lt;numsSize));<span class="comment">//每个数组的长度</span></span><br><span class="line">    result[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    col[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">//拷贝一份，加上当前int</span></span><br><span class="line">        <span class="keyword">int</span> lastCount = count;<span class="comment">//=1 2</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lastCount; j++) &#123;</span><br><span class="line">            size = col[j];<span class="comment">//0 01</span></span><br><span class="line">            result[count] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);<span class="comment">//分配每个数组的存储空间</span></span><br><span class="line">            <span class="comment">// memcpy(result[count],result[j], numsSize); // 这个不行，会报错</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">                result[count][k] = result[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            result[count][size] = nums[i];<span class="comment">//12</span></span><br><span class="line">            col[count] = size+<span class="number">1</span>;<span class="comment">//12</span></span><br><span class="line">            count++;<span class="comment">//23</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *returnSize = count;</span><br><span class="line">    *columnSizes = col;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>** <span class="title">subsets</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>** columnSizes, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    *returnSize=<span class="built_in">pow</span>(<span class="number">2</span>,numsSize);<span class="comment">//首先计算好数组的个数</span></span><br><span class="line">    <span class="keyword">int</span> **result;</span><br><span class="line">    <span class="keyword">int</span> *colSize;</span><br><span class="line">    result=(<span class="keyword">int</span>**) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (*returnSize));<span class="comment">//存储所有数组</span></span><br><span class="line">    colSize=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (*returnSize));<span class="comment">//存储每个数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;*returnSize;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=i;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;<span class="number">1</span>) count++;</span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colSize[i]=count;</span><br><span class="line">        result[i]=(<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(colSize[i]));<span class="comment">//可以为每个result[i]分配具体空间大小</span></span><br><span class="line">    &#125;<span class="comment">//初始化每个数组(大小)（哪一位上有1哪一个数就出现（bitmap）——有多少个1就含多少个数）</span></span><br><span class="line">    * columnSizes=colSize;<span class="comment">//column的一级指针指向colsize的地址，二级指针指向存储的size数据；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;*returnSize;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=i;</span><br><span class="line">        <span class="keyword">int</span> col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                result[i][col++]=nums[j];<span class="comment">//低位上有值时col++</span></span><br><span class="line">            &#125;                </span><br><span class="line">            j++;<span class="comment">//  找到放入当前col的数，j++</span></span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//x记录的是需要放进数组的所有数，nums[j]记录的是当前放进的位</span></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>leetcode 486 predict winner:<strong>（nice solution！！！！！）</strong></p>
<ul>
<li><p>选数字问题。按一定规则（两端）选数字，看哪个人选到的数字之和最大</p>
</li>
<li><p>思路：不需要删除，设置两个指针，分别指向两端。</p>
</li>
<li><p>思路：dp问题？子问题？player1的数字总和不重要。重要的是他是否比player2多。</p>
<p>recursive problem—— use the status on one step to calculate the answer for the next step.</p>
<p>方法：player1先选，player2 再选；设置两个函数，<strong>每次选择的返回作为上一次上一个player选择返回的结果的一部分</strong>（原理：<strong>只要每一次选择都是由后面多次选择的结果，只要多次选择结果中有正确的一次，则player一定会选择使他正确的分数</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first(<span class="number">0</span>, <span class="number">0</span>,nums,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">first</span><span class="params">(<span class="keyword">int</span> s1,<span class="keyword">int</span> s2,<span class="keyword">int</span>* nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//player1 choose</span></span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1&gt;=s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !second(s1+nums[start],s2,nums,start+<span class="number">1</span>,end)<span class="comment">//player1 choose start </span></span><br><span class="line">           ||!second(s1+nums[end],s2,nums,start,end<span class="number">-1</span>); <span class="comment">//player1 choose end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">second</span><span class="params">(<span class="keyword">int</span> s1,<span class="keyword">int</span> s2,<span class="keyword">int</span>* nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//player2 choose</span></span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1&lt;s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !first(s1,s2+nums[start],nums,start+<span class="number">1</span>,end)</span><br><span class="line">           ||!first(s1,s2+nums[end],nums,start,end<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>解法二：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sums[n + <span class="number">1</span>];</span><br><span class="line">    sums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f[n][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> g[n][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        f[i][i + <span class="number">1</span>] = nums[i];</span><br><span class="line">        g[i][i + <span class="number">1</span>] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len;</span><br><span class="line">            <span class="keyword">int</span> sum = sums[j] - sums[i];</span><br><span class="line">            <span class="keyword">if</span> (g[i + <span class="number">1</span>][j] &lt; g[i][j - <span class="number">1</span>])</span><br><span class="line">                f[i][j] = sum - g[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = sum - g[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (f[i + <span class="number">1</span>][j] &lt; f[i][j - <span class="number">1</span>])</span><br><span class="line">                g[i][j] = sum - f[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                g[i][j] = sum - f[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (f[<span class="number">0</span>][n]*<span class="number">2</span> &gt;= sums[n] - sums[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
